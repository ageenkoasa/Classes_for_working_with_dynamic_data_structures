#pragma once

using namespace std;

//!!! Односвязный список - это динамическая структура данных, состоящая из узлов.
//Каждый узел будет иметь какое-то значениеs и указатель на следующий узел.

//!!! Двусвязный список - это структура данных, которая состоит из узлов, которые хранят полезные данные, 
//указатели на предыдущий узел и следующий узел. 
//В случае, когда в списке нет элементов, оба они равны нулю. 
//Если в списке один элемент, то оба указателя ссылаются на один и тот же элемент (соответственное, они равны).

//Операции над абстрактным списком:
//1. Создать пустой список. createList()+
//2. Уничтожить список. destroyList()+
//3. Определить, пуст ли список. isEmpty()+
//4. Определить количество элементов в списке. getLength()+
//5. Вставить элемент в указанную позицию списка. insert()+
//6. Удалить элемент, находящийся в указанной позиции списка. remove()+
//7. Просмотреть(извлечь) элемент, находящийся в указанной позиции списка. retrieve()+



//10. Построить класс для работы с односвязным списком.
//Элементы списка – целые числа.
//Создать список List1.
//Построить список List2, содержащий порядковые номера максимальных элементов списка List1.

struct Node { //узел связанного списка
	int field;
	struct Node* next;
	friend class List;
};

class List {
	Node* head;
	int length;
public:
	List(); // Создание пустого списка - List(0)
	List(const char*);
	List(int); //Создание списка заданной длины
	List(int[], int size);

	List(const List& aList);	//конструктор копирования
	List operator=(const List& list2);

	bool isEmpty() const; // Определяет, пуст ли список
	int getLength() const; // Возвращает количество элементов, содержащихся в списке
	void insert(int index, int value); // Вставляет элемент newltem в список на позицию index
	void remove(int index); // Удаляет из списка элемент, находящийся на позиции index

	int getValue(Node*);
	void setValue(Node* p, int value);
	void show();
	Node* find(int index) const;	// Возвращает указатель на узел с номером index 
	Node* getFirst();
	Node* getLast();
	Node* next(Node*);

	friend ofstream& operator<<(ofstream& f, List& obj);

	~List(); // Уничтожение списка - destroyList()
};